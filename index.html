<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lens RX Simulator v54.4</title>
    <style>
        :root {
            --bg-color: #1e1e24; --surface-color: #2a2a30; --text-color: #e0e0e0;
            --primary-color: #00bcd4; --border-color: #444; --metric-value-color: #ffffff;
            --zone-blue:   rgba(0, 191, 255, 0.35); --zone-green:  rgba(57, 255, 20, 0.28);
            --zone-yellow: rgba(255, 255, 0, 0.22); --zone-orange: rgba(255, 165, 0, 0.20);
            --zone-red:    rgba(255, 0, 0, 0.18);
        }
        html, body { background-color: var(--bg-color); overscroll-behavior: none; height: 100%; margin: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            display: flex; flex-direction: column; color: var(--text-color); -webkit-font-smoothing: antialiased;
        }
        h1 { font-weight: 300; letter-spacing: 1px; color: var(--primary-color); text-align: center; padding: 0.5em 1em 0; }
        .main-container {
            display: flex; justify-content: center; align-items: flex-start;
            gap: 2em; width: 100%; max-width: 1200px; padding: 1em; box-sizing: border-box;
            flex-grow: 1; margin: 0 auto;
        }
        .controls {
            background-color: var(--surface-color); padding: 1.5em; border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3); width: 360px;
            border: 1px solid var(--border-color); flex-shrink: 0;
        }
        .input-group { margin-bottom: 1.5em; }
        .input-group label {
            display: block; margin-bottom: 0.6em; font-weight: 500; font-size: 0.9em;
            color: #aaa; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .slider-group { display: flex; align-items: center; gap: 0.5em; }
        .slider-group input[type="range"] {
            flex-grow: 1; -webkit-appearance: none; appearance: none;
            height: 8px; background: #444; border-radius: 5px; outline: none; padding: 0; margin: 0;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 22px; height: 22px;
            background: var(--primary-color); cursor: pointer; border-radius: 50%;
        }
        .precision-btn {
            background: #444; border: 1px solid var(--border-color); color: var(--text-color);
            width: 30px; height: 30px; border-radius: 50%; font-size: 1.4em;
            line-height: 28px; text-align: center; cursor: pointer; user-select: none; flex-shrink: 0;
        }
        .slider-group span { font-size: 1.1em; font-weight: bold; color: #fff; min-width: 60px; text-align: right; }
        .cal-row { display: flex; align-items: center; gap: 0.5em; }
        .cal-row input[type="number"] { width: 4em; background: #1a1a1f; color: #fff; border: 1px solid #555; border-radius: 6px; padding: 0.4em 0.5em; font-size: 0.9em; text-align: right; }
        .cal-row button { background: var(--primary-color); color: #000; border: 0; border-radius: 6px; font-size: 0.8em; font-weight: 600; padding: 0.4em 0.6em; cursor: pointer; }
        .calibration-hint { color: #777; font-size: 0.7em; line-height: 1.3em; margin-top: 0.4em; }
        .scale-readout { color: #aaa; font-size: 0.8em; margin-top: 0.4em; font-family: monospace; }
        .toggle-row, .lens-side-row { display: flex; align-items: center; gap: 1em; font-size: 0.9em; color: #ddd; }
        .toggle-row input[type="checkbox"], .lens-side-row input[type="radio"] { accent-color: var(--primary-color); }
        #progressiveControls { display: none; border-top: 1px solid var(--border-color); margin-top: 1.5em; padding-top: 1.5em;}
        
        .visualization-area { display: flex; flex-direction: column; align-items: center; gap: 1.5em; flex-grow: 1; width: 100%; }
        .canvas-wrapper {
            position: relative; width: 100%; max-width: 80vh;
            flex-grow: 1; aspect-ratio: 1 / 1;
            background-color: var(--surface-color); border-radius: 12px; overflow: hidden;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3); border: 1px solid var(--border-color);
        }
        #lensCanvas { width: 100%; height: 100%; display: block; }
        
        .metrics-box {
            background-color: var(--surface-color); border: 1px solid var(--border-color); border-radius: 12px;
            padding: 1.5em; width: 100%; max-width: 80vh; box-sizing: border-box;
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5em; position: relative;
        }
        .metric { text-align: center; position: relative; cursor: pointer; transition: opacity 0.2s; }
        .metric:hover { opacity: 0.8; }
        .metric-label { font-size: 0.8em; color: #aaa; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.4em; display: flex; align-items: center; justify-content: center; gap: 5px;}
        .metric-value { font-size: 1.25em; font-weight: bold; color: var(--metric-value-color); line-height: 1.2em; }
        .metric-sub { font-size: 0.7em; color: #777; margin-top: 0.2em; }
        .info-icon { font-size: 0.8em; color: var(--primary-color); border: 1px solid var(--primary-color); border-radius: 50%; width: 14px; height: 14px; line-height: 12px; text-align: center; display: inline-block; }

        .risk-popup {
            display: none; position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%);
            width: 320px; background: rgba(30, 30, 36, 0.98); border: 1px solid var(--primary-color);
            border-radius: 8px; padding: 18px; box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            z-index: 100; backdrop-filter: blur(10px); text-align: left;
        }
        .risk-popup.active { display: block; }
        .risk-popup h4 { margin: 0 0 10px 0; color: var(--primary-color); font-size: 1em; border-bottom: 1px solid #444; padding-bottom: 5px; }
        
        .risk-scale { font-size: 0.75em; margin: 10px 0; display: flex; flex-direction: column; gap: 2px; }
        .band-item { display: flex; justify-content: space-between; padding: 2px 6px; border-radius: 3px; color: #888; }
        .band-item.active { background: var(--primary-color); color: #000; font-weight: bold; }
        .band-item.best { border: 1px dashed var(--primary-color); color: var(--primary-color); }
        
        .driver-list { margin-top: 12px; }
        .driver-list h5 { font-size: 0.75em; text-transform: uppercase; color: #aaa; margin: 0 0 5px 0; }
        .driver-tag { display: inline-block; font-size: 0.65em; background: #444; padding: 2px 6px; border-radius: 10px; margin: 0 4px 4px 0; color: #eee; }
        
        .best-comparison { margin-top: 10px; padding-top: 8px; border-top: 1px solid #444; font-size: 0.75em; color: #00bcd4; font-style: italic; }

        .popup-arrow {
            position: absolute; bottom: -8px; left: 50%; margin-left: -8px;
            width: 0; height: 0; border-left: 8px solid transparent;
            border-right: 8px solid transparent; border-top: 8px solid var(--primary-color);
        }

        @media (max-width: 900px) {
            .main-container { flex-direction: column-reverse; padding-bottom: 80px; }
            .controls { position: fixed; bottom: 10px; left: 10px; right: 10px; width: auto; z-index: 10; background: rgba(42, 42, 48, 0.9); backdrop-filter: blur(10px); }
            .controls.is-collapsed .controls-body { display: none; }
            .controls-header { display: block; text-align: center; padding: 15px; cursor: pointer; background: rgba(0,0,0,0.2); }
            .controls-body { padding: 1.5em; max-height: 60vh; overflow-y: auto; }
        }
    </style>
</head>
<body>
    <h1>Lens RX Simulator</h1>
    <div class="main-container">
        <div class="controls is-collapsed">
            <div class="controls-header">Show Controls</div>
            <div class="controls-body">
                <div class="input-group"><label>Spherical Power (SPH)</label><div class="slider-group"><div class="precision-btn" id="sph-minus">-</div><input type="range" id="sphere" min="-15" max="10" value="-10.00" step="0.25"><div class="precision-btn" id="sph-plus">+</div><span id="sphereValue">-10.00</span></div></div>
                <div class="input-group"><label>Cylindrical Power (CYL)</label><div class="slider-group"><div class="precision-btn" id="cyl-minus">-</div><input type="range" id="cylinder" min="-6" max="6" value="4.50" step="0.25"><div class="precision-btn" id="cyl-plus">+</div><span id="cylinderValue">4.50</span></div></div>
                <div class="input-group"><label>Axis</label><div class="slider-group"><input type="range" id="axis" min="0" max="180" value="105" step="1"><span id="axisValue">105</span></div></div>
                <div class="input-group"><label>Lens Material</label><div class="slider-group"><input type="range" id="materialSlider" min="0" max="4" value="3"><span id="materialName">1.67 HI</span></div></div>
                <div class="input-group"><label>Decentration (D_mm)</label><div class="slider-group"><input type="range" id="decentration" min="15" max="50" value="32.0" step="0.5"><span id="decentrationValue">32.0 mm</span></div></div>

                <div class="input-group">
                    <label>Configuration & Analysis</label>
                    <div class="lens-side-row" style="margin-bottom: 0.8em;"><label>Ocular View:</label><label><input type="radio" name="lensSide" id="lensRight" value="R" checked><span>R</span></label><label><input type="radio" name="lensSide" id="lensLeft" value="L"><span>L</span></label></div>
                    <div class="toggle-row" style="margin-bottom: 0.6em;"><label><input type="checkbox" id="bestPossibleToggle" /><span>Show "Best Case" Comparison</span></label></div>
                    <div class="toggle-row" style="margin-bottom: 0.6em;"><label><input type="checkbox" id="rulerToggle" /><span>Show Seg Height Ruler</span></label></div>
                    <div class="toggle-row"><label><input type="checkbox" id="progressiveToggle" /><span>Enable Progressive</span></label></div>
                    <div id="progressiveControls">
                        <div class="input-group" style="margin-top: 1.5em;"><label>ADD Power</label><div class="slider-group"><input type="range" id="addPower" min="0.75" max="3.50" value="2.00" step="0.25"><span id="addPowerValue">+2.00</span></div></div>
                    </div>
                </div>
                <div class="input-group"><label>Screen Calibration</label><div class="cal-row"><input type="number" id="measuredMm" value="36" min="10" max="100" step="0.1"><span>measured mm</span><button id="applyCalBtn">Apply</button></div><div class="scale-readout">Scale: <span id="scaleValue">1.00×</span></div></div>
            </div>
        </div>
        
        <div class="visualization-area">
            <div class="canvas-wrapper"><canvas id="lensCanvas"></canvas></div>
            <div class="metrics-box">
                <div class="metric"><div class="metric-label">Comfort Zone</div><div class="metric-value" id="clarityDiameterValue">-- mm</div></div>
                
                <div class="metric" id="riskMetricBtn">
                    <div class="metric-label">Comfort Risk <span class="info-icon">?</span></div>
                    <div class="metric-value" id="riskValue">--</div>
                    <div class="metric-sub" id="riskConfidence">Confidence: --</div>
                    <div class="risk-popup" id="riskPopup">
                        <h4>Optical Comfort Risk</h4>
                        <div class="risk-scale" id="riskScaleContainer"></div>
                        <div class="driver-list" id="driverList"></div>
                        <div class="best-comparison" id="bestCompareLine" style="display:none;"></div>
                        <div class="popup-arrow"></div>
                    </div>
                </div>
                
                <div class="metric"><div class="metric-label">Center Thickness</div><div class="metric-value" id="centerThicknessValue">-- mm</div></div>
                <div class="metric"><div class="metric-label">Est. Edge Thickness</div><div class="metric-value" id="edgeThicknessValue">-- mm</div></div>
            </div>
        </div>
    </div>

<script>
// =========================
// SETUP
// =========================
const ui = {};
['sphere','sphereValue','cylinder','cylinderValue','axis','axisValue','materialSlider','materialName',
 'decentration', 'decentrationValue', 'clarityDiameterValue','riskValue','riskConfidence', 'centerThicknessValue','edgeThicknessValue',
 'sph-minus','sph-plus','cyl-minus','cyl-plus','measuredMm','applyCalBtn','scaleValue',
 'progressiveToggle','progressiveControls','addPower','addPowerValue','lensRight','lensLeft', 'rulerToggle', 'bestPossibleToggle'].forEach(id => ui[id] = document.getElementById(id));

const canvas = document.getElementById('lensCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
const controls = document.querySelectorAll('.controls input');
const controlsContainer = document.querySelector('.controls');
const controlsHeader = document.querySelector('.controls-header');

let dpr = 1, basePxPerMmPhysical = 4, calibrationScale = 1.0;

const MATERIALS = {
  "1.50": { name: "CR-39 (1.50)",         n: 1.50, centerThickness: 1.9, minEdge: 2.0, factor: 0.8 },
  "1.59": { name: "Polycarbonate (1.59)", n: 1.59, centerThickness: 1.6, minEdge: 1.5, factor: 1.2 }, 
  "1.60": { name: "High Index (1.60)",    n: 1.60, centerThickness: 1.1, minEdge: 1.5, factor: 1.8 }, 
  "1.67": { name: "High Index (1.67)",    n: 1.67, centerThickness: 1.1, minEdge: 1.5, factor: 2.5 }, 
  "1.74": { name: "High Index (1.74)",    n: 1.74, centerThickness: 1.1, minEdge: 1.5, factor: 3.5 } 
};
const MATERIAL_KEYS = Object.keys(MATERIALS);

const RISK_BANDS = [
    { range: [0, 5], label: "Near-Perfect" },
    { range: [6, 12], label: "Excellent" },
    { range: [13, 20], label: "Very Good" },
    { range: [21, 30], label: "Good" },
    { range: [31, 40], label: "Mostly Fine" },
    { range: [41, 50], label: "Borderline" },
    { range: [51, 60], label: "Challenging" },
    { range: [61, 70], label: "High Risk" },
    { range: [71, 82], label: "Very High Risk" },
    { range: [83, 92], label: "Severe Risk" },
    { range: [93, 100], label: "Fishbowl Territory" }
];

// =========================
// UTILITIES
// =========================
function lerp(a,b,t){return a+(b-a)*t;}
function clamp(v,min,max){return Math.max(min, Math.min(max,v));}
function clamp01(v) { return clamp(v, 0, 1); }
function getAnisotropy(cyl){ return Math.min(1 + 0.12 * Math.abs(cyl), 1.6); }

function normalizeRx(sph, cyl, axis) {
    if (cyl > 0) return { sph: sph + cyl, cyl: -cyl, axis: (axis + 90) % 180 };
    return { sph, cyl, axis };
}

function getBandData(score) {
    return RISK_BANDS.find(b => score >= b.range[0] && score <= b.range[1]) || RISK_BANDS[RISK_BANDS.length-1];
}

function calculateBaseScale() {
    const p = document.createElement('div'); p.style.cssText='position:absolute;top:-999px;width:1mm;';
    document.body.appendChild(p); dpr = window.devicePixelRatio || 1;
    basePxPerMmPhysical = (p.getBoundingClientRect().width || 3.78) * dpr;
    document.body.removeChild(p);
}

function getPxPerMm() { return basePxPerMmPhysical * calibrationScale; }

function setupCanvas() {
    const r = canvas.getBoundingClientRect(); dpr = window.devicePixelRatio||1;
    canvas.width=Math.round(r.width*dpr); canvas.height=Math.round(r.height*dpr);
    canvas.logicalWidth=canvas.width; canvas.logicalHeight=canvas.height;
    offscreenCanvas.width=canvas.width; offscreenCanvas.height=canvas.height;
}

// =========================
// MATH ENGINES
// =========================

function calculateThicknesses(p) {
    const D_mm = p.decentration;
    const maxMeridianPower = Math.abs(p.sph) > Math.abs(p.sph + p.cyl) ? p.sph : (p.sph + p.cyl);
    const refractiveFactor = 2000 * (p.material.n - 1);
    const sagitta = (D_mm * D_mm * Math.abs(maxMeridianPower)) / refractiveFactor;
    let centerT, edgeT;
    if (maxMeridianPower > 0) { edgeT = p.material.minEdge; centerT = edgeT + sagitta; } 
    else { centerT = p.material.centerThickness; edgeT = centerT + sagitta; }
    return { centerT, edgeT };
}

function calculateRisk(p) {
    const SE = p.sph + p.cyl/2;
    const absSE = Math.abs(SE);
    const absCyl = Math.abs(p.cyl);
    const decOver = Math.max(0, p.decentration - 24);

    const seN = 1 - Math.exp(-absSE / 8.0); 
    const cylN = 1 - Math.exp(-absCyl / 3.0);
    const decN = 1 - Math.exp(-decOver / 14.0); 
    const plusN = clamp01(SE / 9);
    const progN = p.prog ? 1 : 0;
    const indexMitigation = clamp01((p.material.n - 1.50) / 0.24); 

    const comp1 = seN * decN;
    const comp2 = cylN * decN;
    const comp3 = seN * cylN * 0.7;

    let baseScore = (0.44 * seN) + (0.20 * cylN) + (0.20 * decN) + (0.10 * plusN) + (0.15 * progN);
    let interactionScore = (0.22 * comp1) + (0.12 * comp2) + (0.10 * comp3);
    const materialBenefit = indexMitigation * 0.15 * (seN + 0.5); 

    let score01 = clamp01(baseScore + interactionScore - materialBenefit);
    const riskScore = Math.round(100 * Math.pow(score01, 1.05));

    const midPenalty = 1 - Math.abs((riskScore/100) - 0.5) * 2;
    const confidence = Math.round(100 * clamp(0.92 - 0.18*midPenalty - 0.10*decN, 0.2, 0.95));

    const drivers = [];
    if (absSE > 5) drivers.push("High SE Rx");
    if (absCyl > 2.5) drivers.push("Significant CYL");
    if (p.decentration > 36) drivers.push("Significant Decentration");
    if (p.prog) drivers.push("Progressive Overlay");
    if (indexMitigation > 0.4) drivers.push("Index Mitigation Active");

    return { riskScore, confidence, drivers };
}

function calculateBestCase(p) {
    const normalized = normalizeRx(p.sph, p.cyl, p.axis);
    const SE = p.sph + p.cyl/2;
    const absSE = Math.abs(SE);
    const targetMaterial = (absSE > 4.5 || p.decentration > 38) ? MATERIALS["1.74"] : MATERIALS["1.60"];
    const targetDec = 31; 

    const bestP = { ...normalized, decentration: targetDec, material: targetMaterial, prog: p.prog };
    const baseRisk = calculateRisk(bestP).riskScore;
    const asphBonus = clamp01(absSE / 10) * 0.08;
    const bestScore = Math.round(baseRisk * (1 - asphBonus));
    return { score: bestScore, band: getBandData(bestScore).label, mat: targetMaterial.name, dec: targetDec };
}

// =========================
// RENDERING & UI
// =========================

function updateRiskUI(p) {
    const current = calculateRisk(p);
    const band = getBandData(current.riskScore);
    
    ui.riskValue.textContent = `${band.label} (${current.riskScore})`;
    ui.riskConfidence.textContent = `Confidence: ${current.confidence}%`;

    let scaleHtml = "";
    let bestCase = null;
    if (ui.bestPossibleToggle.checked) {
        bestCase = calculateBestCase(p);
        document.getElementById('bestCompareLine').style.display = 'block';
        document.getElementById('bestCompareLine').textContent = `Best Case (${bestCase.mat} @ ${bestCase.dec}mm): ${bestCase.band} (${bestCase.score})`;
    } else {
        document.getElementById('bestCompareLine').style.display = 'none';
    }

    RISK_BANDS.forEach(b => {
        const isActive = b.label === band.label;
        const isBest = bestCase && b.label === bestCase.band;
        scaleHtml += `<div class="band-item ${isActive ? 'active' : ''} ${isBest ? 'best' : ''}">
            <span>${b.label}</span><span>${b.range[0]}-${b.range[1]}</span>
        </div>`;
    });
    document.getElementById('riskScaleContainer').innerHTML = scaleHtml;

    let driversHtml = "<h5>Risk Factors & Mitigation</h5>";
    if (current.drivers.length === 0) driversHtml += "<div class='driver-tag'>Standard Geometry</div>";
    current.drivers.forEach(d => driversHtml += `<div class='driver-tag'>${d}</div>`);
    document.getElementById('driverList').innerHTML = driversHtml;
}

function calculateSVMetrics(p) {
    const baseP = Math.abs(p.sph);
    const totalP = Math.abs(p.sph + p.cyl);
    const dR = p.material.factor;
    const maxClear = 48;
    const cds = Math.max(10, maxClear - Math.pow(baseP, 1.15) * (4.5 / dR));
    const cdt = Math.max(10, maxClear - Math.pow(totalP, 1.15) * (4.5 / dR));
    const { centerT, edgeT } = calculateThicknesses(p);
    const risk = calculateRisk(p);
    return { cds, cdt, dS: risk.riskScore, edgeT, centerT, warp: -p.sph * 0.015 * (1 + (2.0/dR)), twist: -p.cyl * 0.08 * (1 + (2.0/dR)) };
}

function drawVisualization() {
    const materialKey = MATERIAL_KEYS[parseInt(ui.materialSlider.value)];
    const rawSph = parseFloat(ui.sphere.value) || 0;
    const rawCyl = parseFloat(ui.cylinder.value) || 0;
    const rawAxis = parseInt(ui.axis.value) || 0;
    const normalized = normalizeRx(rawSph, rawCyl, rawAxis);
    
    const p={
        sph: normalized.sph, cyl: normalized.cyl, axis: normalized.axis,
        decentration: parseFloat(ui.decentration.value) || 0,
        material: MATERIALS[materialKey], 
        prog: ui.progressiveToggle.checked, 
        showRuler: ui.rulerToggle.checked,
        side: document.querySelector('input[name="lensSide"]:checked').value,
        add: (ui.progressiveToggle.checked && ui.addPower) ? parseFloat(ui.addPower.value) : 0
    };
    
    const metrics=calculateSVMetrics(p);
    ui.clarityDiameterValue.textContent=`${Math.min(metrics.cds, metrics.cdt).toFixed(1)} mm`;
    ui.centerThicknessValue.textContent = `${metrics.centerT.toFixed(1)} mm`;
    ui.edgeThicknessValue.textContent = `${metrics.edgeT.toFixed(1)} mm`;
    
    updateRiskUI(p);
    createWarpBackground(offscreenCtx, canvas.width, canvas.height, p, metrics);
    drawRayMappedView(p, metrics);
    drawClinicalOverlay(p, metrics);
}

// =========================
// CANVAS CORE
// =========================
function createWarpBackground(oCtx, w, h, p, m) {
    oCtx.clearRect(0,0,w,h);
    if(p.prog) drawProgressiveHeatMap(oCtx, w, h, p, m);
    else drawAdvancedSVHeatmap(oCtx, w, h, p, m);
}

function drawAdvancedSVHeatmap(ctx2, w, h, p, metrics){
    const cx=w/2, cy=h/2, pxPerMm=getPxPerMm();
    const maxRpx = Math.sqrt(w*w+h*h)/2;
    const clearRpx = Math.min(metrics.cds, metrics.cdt)/2 * pxPerMm;
    const isPlus = (p.sph + p.cyl/2) > 0;
    ctx2.save();
    ctx2.translate(cx, cy); ctx2.rotate(p.axis*Math.PI/180);
    ctx2.scale(getAnisotropy(p.cyl), 1/getAnisotropy(p.cyl));
    const grad = ctx2.createRadialGradient(0, 0, clearRpx * (isPlus?0.45:0.25), 0, 0, maxRpx);
    if (isPlus) { grad.addColorStop(0, 'rgba(255, 100, 0, 1)'); grad.addColorStop(0.3, 'rgba(0, 191, 255, 1)'); grad.addColorStop(clearRpx/maxRpx, 'rgba(57, 255, 20, 1)'); grad.addColorStop(1, 'rgba(255, 0, 0, 1)'); }
    else { grad.addColorStop(0, 'rgba(0, 191, 255, 1)'); grad.addColorStop(clearRpx/maxRpx, 'rgba(57, 255, 20, 1)'); grad.addColorStop((clearRpx*1.4)/maxRpx, 'rgba(255, 255, 0, 1)'); grad.addColorStop(1, 'rgba(255, 0, 0, 1)'); }
    ctx2.fillStyle = grad; ctx2.fillRect(-maxRpx*2, -maxRpx*2, maxRpx*4, maxRpx*4);
    ctx2.restore();
}

/**
 * REVERTED PROGRESSIVE VISUALS (As per Snippet)
 * Wide sin-wave corridor, polynomial nasal inset.
 */
function drawProgressiveHeatMap(ctx2, w, h, p, metrics){
    const pxPerMm=getPxPerMm(), cx=w/2, cy=h/2;
    const dropMm=11, insetMm=3, nasalSign=(p.side==='R'?-1:1);
    const dropPx=dropMm*pxPerMm, insetPx=insetMm*pxPerMm;
    
    // Internal dStrength from Risk Model for color intensity
    const riskStrength = clamp(metrics.dS/100,0,1);
    const baseWidthTop = lerp(12, 5, riskStrength), baseWidthBot = lerp(7, 4, riskStrength);
    
    function centerX(y){ const t=clamp((y-cy)/dropPx,0,1); return cx+nasalSign*insetPx*(t*(1-0.3*t)-0.15*Math.pow(t,3)); }
    function halfWidth(y){ const t=clamp((y-cy)/dropPx,0,1); return (lerp(baseWidthTop,baseWidthBot,t)*(1-0.6*Math.sin(Math.PI*t)))*pxPerMm; }

    ctx2.fillStyle='rgba(255,0,0,1)'; ctx2.fillRect(0,0,w,h);
    const imgData=ctx2.getImageData(0,0,w,h), data=imgData.data;
    
    for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
            const dx=x-cx, dy=y-cy;
            const cX=centerX(y), hW=halfWidth(y)||1;
            const distFromCorr=Math.abs(x-cX)/hW;
            
            let vPenalty=0;
            if(y < cy-6*pxPerMm) vPenalty = ((cy-6*pxPerMm)-y)/(6*pxPerMm);
            if(y > cy+dropPx+4*pxPerMm) vPenalty = (y-(cy+dropPx+4*pxPerMm))/(6*pxPerMm);
            
            const astigPenalty = clamp(distortionScoreAt(dx,dy,w,h,p,metrics)*3.0,0,5);
            const isNasal = (x-cx)*nasalSign > 0;
            const nasalBoost = clamp(isNasal ? Math.abs(x-cx)/(10*pxPerMm) : 0, 0, 1.2)*clamp((y-cy)/dropPx,0,1);
            
            let clarityScore = distFromCorr*(1.2+riskStrength*2.0)+astigPenalty*(0.8+nasalBoost)+clamp(vPenalty,0,2)*0.7;
            clarityScore*=(0.6+0.4*clamp((y-cy)/dropPx,0,1));
            
            const col=heatColor(clamp(clarityScore/3.5,0,1));
            const parts=col.match(/\d+/g);
            const idx=(y*w+x)*4;
            data[idx]=parseInt(parts[0]); data[idx+1]=parseInt(parts[1]); data[idx+2]=parseInt(parts[2]); data[idx+3]=255;
        }
    }
    ctx2.putImageData(imgData,0,0);
}

function distortionScoreAt(dx, dy, w, h, p, metrics) {
    const r = Math.sqrt(dx*dx + dy*dy), maxR = Math.sqrt(w*w + h*h)/2, rNorm = r/maxR;
    const theta = Math.atan2(dy, dx), axisRad = (p.axis*Math.PI)/180;
    const radial = Math.abs(metrics.warp) * Math.pow(rNorm, 1.6);
    const nasalBias = (p.side === 'R' && dx > 0) || (p.side === 'L' && dx < 0) ? 1.15 : 0.95;
    const twist = Math.abs(metrics.twist) * nasalBias * Math.pow(rNorm, 2.1) * Math.abs(Math.sin(2*(theta - axisRad)));
    return radial + twist;
}

function drawRayMappedView(p, metrics) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(offscreenCanvas, 0, 0);
    drawDistortedGrid(ctx, canvas.width, canvas.height, p, metrics);
}

function drawDistortedGrid(ctx2, w, h, p, metrics) {
    const pxPerMm = getPxPerMm();
    const step = 4.0 * pxPerMm; const cx = w/2, cy = h/2;
    ctx2.strokeStyle = 'rgba(0,0,0,0.3)'; ctx2.lineWidth = 1.1*dpr; ctx2.beginPath();
    const getPt = (ox, oy) => {
        let dx = ox - cx, dy = oy - cy;
        const r = Math.sqrt(dx*dx + dy*dy), rNorm = r / (w/2), theta = Math.atan2(dy, dx);
        let power = p.sph; if(p.prog && dy > 0) power += p.add * clamp(dy/(12*pxPerMm),0,1);
        const mag = 1 / (1 - (power * 0.045 * (1.55/p.material.n)));
        const finalR = r * mag * (1 + metrics.warp * 2.8 * 0.18 * rNorm**2);
        const twistAngle = metrics.twist * 2.8 * 0.18 * rNorm**2.2 * Math.sin(2*(theta - p.axis*Math.PI/180));
        return { x: cx + finalR * Math.cos(theta - twistAngle), y: cy + finalR * Math.sin(theta - twistAngle) };
    };
    const buf = w*0.6;
    for(let x=-buf; x<=w+buf; x+=step){
        for(let y=-buf; y<=h+buf; y+=15){
            const pt = getPt(x,y); if(y===-buf) ctx2.moveTo(pt.x, pt.y); else ctx2.lineTo(pt.x, pt.y);
        }
    }
    for(let y=-buf; y<=h+buf; y+=step){
        for(let x=-buf; x<=w+buf; x+=15){
            const pt = getPt(x,y); if(x===-buf) ctx2.moveTo(pt.x, pt.y); else ctx2.lineTo(pt.x, pt.y);
        }
    }
    ctx2.stroke();
}

function drawClinicalOverlay(p, metrics) {
    const w=canvas.logicalWidth, h=canvas.logicalHeight, pxPerMm=getPxPerMm();
    const cx=w/2, cy=h/2;
    ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=2; ctx.beginPath();
    ctx.moveTo(cx-12*dpr, cy); ctx.lineTo(cx+12*dpr, cy); ctx.moveTo(cx, cy-12*dpr); ctx.lineTo(cx, cy+12*dpr); ctx.stroke();
    
    // UPDATED: BLACK RULER
    if (p.showRuler) {
        ctx.save(); 
        ctx.strokeStyle = '#000000'; 
        ctx.fillStyle = '#000000'; 
        ctx.font = `bold ${11*dpr}px monospace`;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, h); ctx.stroke();
        for (let i = 1; i < 65; i++) {
            const ty = cy + (i * pxPerMm); if (ty > h) break;
            const is5 = i % 5 === 0; const tw = is5 ? 14*dpr : 7*dpr;
            ctx.beginPath(); ctx.moveTo(cx-tw/2, ty); ctx.lineTo(cx+tw/2, ty); ctx.stroke();
            if (is5) ctx.fillText(i.toString(), cx + 12*dpr, ty);
        }
        ctx.restore();
    }
    
    // Progressive Markers (Fitting Cross / Near Circle)
    if (p.prog) {
        const distY = cy - (4 * pxPerMm);
        const nasalSign = (p.side === 'R' ? -1 : 1);
        const nearX = cx + (3 * nasalSign * pxPerMm);
        const nearY = cy + (17 * pxPerMm);
        ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.setLineDash([]);
        ctx.beginPath(); ctx.arc(cx, distY, 4*pxPerMm, 0, 2*Math.PI); ctx.stroke();
        ctx.beginPath(); ctx.arc(nearX, nearY, 4*pxPerMm, 0, 2*Math.PI); ctx.stroke();
        ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.font=`${10*dpr}px sans-serif`; ctx.textAlign='center';
        ctx.fillText("DIST", cx, distY - 6*pxPerMm);
        ctx.fillText("NEAR", nearX, nearY + 7*pxPerMm);
    } else {
        const comfortR = Math.min(metrics.cds, metrics.cdt)/2 * pxPerMm;
        const axisRad = (p.axis*Math.PI)/180;
        const aniso = getAnisotropy(p.cyl);
        ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,0.7)'; 
        ctx.beginPath(); ctx.ellipse(cx, cy, comfortR*aniso, comfortR/aniso, axisRad, 0, 2*Math.PI); ctx.stroke();
    }
    
    drawCalibrationBar(pxPerMm, w, h, metrics.edgeT);
}

function drawCalibrationBar(pxPerMm, w, h, tMm){
    const bw=50*pxPerMm, bh=tMm*pxPerMm, m=20*dpr;
    ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(m, h-bh-m, bw, bh);
    ctx.fillStyle='#fff'; ctx.font=`${11*dpr}px sans-serif`; ctx.textAlign='left';
    ctx.fillText('50mm Calib', m, h-bh-m-4*dpr);
    ctx.textAlign='right'; ctx.fillText(`${tMm.toFixed(1)}mm`, m+bw, h-bh-m-4*dpr);
}

function heatColor(t){
    t = clamp(t, 0, 1); let r, g, b;
    if(t < 0.25){ r=lerp(0, 57, t/0.25); g=lerp(191, 255, t/0.25); b=lerp(255, 20, t/0.25); }
    else if(t < 0.5){ r=lerp(57, 255, (t-0.25)/0.25); g=255; b=lerp(20, 0, (t-0.25)/0.25); }
    else if(t < 0.75){ r=255; g=lerp(255, 165, (t-0.5)/0.25); b=0; }
    else{ r=255; g=lerp(165, 0, (t-0.75)/0.25); b=0; }
    return `rgba(${r.toFixed(0)},${g.toFixed(0)},${b.toFixed(0)},1.0)`; 
}

// =========================
// UI HELPERS
// =========================
function updateAndRedraw(){
    ui.sphereValue.textContent = parseFloat(ui.sphere.value).toFixed(2);
    ui.cylinderValue.textContent = parseFloat(ui.cylinder.value).toFixed(2);
    ui.axisValue.textContent = ui.axis.value;
    ui.decentrationValue.textContent = `${parseFloat(ui.decentration.value).toFixed(1)} mm`;
    ui.materialName.textContent = MATERIALS[MATERIAL_KEYS[parseInt(ui.materialSlider.value)]].name;
    if(ui.progressiveToggle.checked && ui.addPowerValue) ui.addPowerValue.textContent = `+${parseFloat(ui.addPower.value).toFixed(2)}`;
    drawVisualization();
}

function adjustSlider(s, v){
    s.value=clamp(parseFloat(s.value)+v, parseFloat(s.min), parseFloat(s.max));
    updateAndRedraw();
}

// POPUP HANDLER
const riskBtn = document.getElementById('riskMetricBtn');
const riskPopup = document.getElementById('riskPopup');
riskBtn.addEventListener('click', (e) => { e.stopPropagation(); riskPopup.classList.toggle('active'); });
document.addEventListener('click', () => riskPopup.classList.remove('active'));

controlsHeader.addEventListener('click', () => {
    const isCollapsed = controlsContainer.classList.toggle('is-collapsed');
    controlsHeader.textContent = isCollapsed ? 'Show Controls' : 'Hide Controls';
});

// LISTENERS
ui.progressiveToggle.addEventListener('input', () => {
    ui.progressiveControls.style.display = ui.progressiveToggle.checked ? 'block' : 'none';
    updateAndRedraw();
});
ui.bestPossibleToggle.addEventListener('input', updateAndRedraw);
ui.rulerToggle.addEventListener('input', updateAndRedraw);
document.querySelectorAll('input[name="lensSide"]').forEach(r => r.addEventListener('input', updateAndRedraw));
controls.forEach(el=> el.addEventListener('input', updateAndRedraw));
ui['sph-minus'].addEventListener('click',()=>adjustSlider(ui.sphere, -0.25));
ui['sph-plus'].addEventListener('click',()=>adjustSlider(ui.sphere, 0.25));
ui['cyl-minus'].addEventListener('click',()=>adjustSlider(ui.cylinder, -0.25));
ui['cyl-plus'].addEventListener('click',()=>adjustSlider(ui.cylinder, 0.25));
ui.applyCalBtn.addEventListener('click',()=>{
    const m=parseFloat(ui.measuredMm.value); if(!isFinite(m)||m<=0)return;
    calibrationScale=50/m; ui.scaleValue.textContent=calibrationScale.toFixed(2)+'×'; drawVisualization();
});

window.addEventListener('load',()=>{setTimeout(()=>{
    calculateBaseScale(); setupCanvas(); 
    ui.progressiveControls.style.display = ui.progressiveToggle.checked ? 'block' : 'none';
    if (window.innerWidth <= 900) controlsContainer.classList.add('is-collapsed');
    updateAndRedraw();
},50);});
window.addEventListener('resize',()=>{setupCanvas(); drawVisualization();});

</script>
</body>
</html>
